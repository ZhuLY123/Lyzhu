/* this program is to merge two arrays(disorder)
*  author:lingyu zhu
*/

public int[] mergeTwoArray(int[] A, int[] B) {
    int[] C = new int[A.length + B.length];
    int k = 0;
    int i = 0;
    int j = 0;
    while(i < A.length && j < B.length) {
        if (A[i] < B[j])
            C[k++] = A[i++];
        else
            C[k++] = B[j++];
    }
    while (i < A.length)
        C[k++] = A[i++];
    while (j < B.length)
        C[k++] = B[j++];
    return C;
}
//this program does not hava any sense, because merging two arrays just need two while. 


/* this program is to merge two sorted arrays
*  author:lingyu zhu
*  leetcode 
*  Given two sorted integer arrays A and B, merge B into A as one sorted array.
*  Note:
*  You may assume that A has enough space (size that is greater or equal to m + n)
*  to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.
*/

public void merge(int A[], int m, int B[], int n) {
        while(m > 0 && n > 0){
            if(A[m-1] > B[n-1]){
                A[m+n-1] = A[m-1];
                m--;
            }else{
                A[m+n-1] = B[n-1];
                n--;
            }
        }
        while(n > 0){
            A[m+n-1] = B[n-1];
            n--;
        }
    }
    
    
/*  Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
*   Do not allocate extra space for another array, you must do this in place with constant memory.
*   For example,
*   Given input array A =[1,1,2],
*   Your function should return length =2, and A is now[1,2].*/
/*


public class solution {
       public int removeduplicates(int [] A)
       {
             int count = 1;
             for(int i =1;i<A.length;i++)
             {
                    if(A[i]==A[i-1])
                    {
                          continue;
                    }else
                    {
                          A[count] = A[i];
                          count++;
                          
                    }
             }
             
             return count;
                    
       }
}
//trick： the count only count the unequal to previous number



/*Follow up for "Remove Duplicates":
What if duplicates are allowed at most twice?
For example,
Given sorted array A =[1,1,1,2,2,3],
Your function should return length =5, and A is now[1,1,2,2,3].
*/
public class solution {
       
       
       public int removeDupicates(int[] A)
       {
             int count =1;
             int j =1;
             for (int i =1;i<A.length;i++)
             {
                    if(A[i-1]==A[i])
                    {
                          count++;
                          if(count>=3)
                                 continue;   
                    }else
                          count = 1;
                    
                    
                    A[j++]=A[i];
             }
             
             return j;     
       }    
}







/*Suppose a sorted array is rotated at some pivot unknown to you beforehand. 
(i.e.,0 1 2 4 5 6 7might become4 5 6 7 0 1 2). 
You are given a target value to search. If found in the array return its index, otherwise return -1. 
You may assume no duplicate exists in the array. */

public class solution {
	public int search(int[] nums, int target) {

	 if(nums == null || nums.length == 0) return  -1;

     int start = 0, end = nums.length -1 ;
     while (start + 1 < end){
         int mid = start + (end - start)/2 ;
         if(nums[mid] == target) return mid;

         
         
         if(nums[start] < nums[mid]){ 
        	 //引入nums[start]分mid在x轴上和在x轴下两种情况讨论
             //situation 1  红线
             if(nums[mid]> target && nums[start] <= target ){
                 end = mid;
             }else{
                 start= mid;
             }
         }
         
     
         
         else{
             //situation 2 绿线 ，nums[start] >= nums[mid]
             if(nums[mid] <= target && nums[end] >= target){
                 start = mid;
             }else{
                 end =mid;
             }
         }
         
     }//while

     //double check 
     if (nums[start] == target ) return start;
     if (nums[end]== target) return end;
     return -1;
 }

}




Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. 
We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n). 
Example 1:
Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.

Example 2:
Input: [4,2,1]
Output: False
Explanation: You can't get a non-decreasing array by modify at most one element.

the test example ：[3,4,2,3]
*如果一直升序，直接return true ； 碰到降序的时候再返回 false；

public class solution {
	
	public boolean checkPossibility(int [] nums) 
	{
		if(nums == null || nums.length<=1)
			return true;
		
		boolean found = false;
		for(int i =1;i<nums.length;i++) 
		{
			if(nums[i] < nums[i-1]) 
			{
				
				if(found)
					return false;
				else 
				{
					if(i-2>=0 && nums[i]<nums[i-2])
						nums[i] = nums[i-1];
					found = true;
				}	
			}//if 
			
		}//for
		
		
		return true;
	}
}



